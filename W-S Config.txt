Cool, Kotlin + those pairs (USD/BTC, USD/JPY, USD/AUX) + both history + real-time is doable. 
Here’s your “data plumbing toolkit.”

-------------------------------------------------------------------------------
SOURCES THAT SUPPORT HISTORICAL + REAL-TIME FX / CRYPTO FOR YOUR PAIRS
-------------------------------------------------------------------------------

Provider: Finnhub
- Coverage: Forex (USD/JPY etc), Crypto (USD/BTC etc)
- Historical: stock_candles endpoint gives OHLC for stocks / FX / crypto
  https://finnhub.io/docs/api/stock-candles
- Real-time: WebSocket stream of trades / price updates
  https://finnhub.io/docs/api/websocket-trades

Provider: Binance
- Coverage: Crypto (USD/BTC etc)
- Historical: REST endpoints (candlestick / klines) for crypto
- Real-time: WebSocket streams (trade, aggTrade, order book, mark price etc)
  https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams

Provider: Twelve Data
- Coverage: Stocks, Crypto, Forex (includes USD/JPY etc)
- Historical: Candles / quote history via REST
- Real-time: WebSocket for quotes / price streaming

Provider: Alpha Vantage / MarketData.app
- Coverage: Some FX + crypto + USD pairs via REST
- Historical: Yes
- Real-time: Limited or none for free tier

-------------------------------------------------------------------------------
10 PROVIDERS FOR REDUNDANCY
-------------------------------------------------------------------------------

1. Binance (crypto; history + WS)
2. OKX (crypto; history + WS)
3. Kraken (crypto + some FX; history + WS)
4. Twelve Data (crypto/forex/stocks; history + WS)
5. Finnhub (crypto/forex/stocks; history + WS)
6. Financial Modeling Prep (crypto; history limited + WS)
7. Polygon.io (crypto/forex/stocks; history + WS)
8. Alpaca (stocks+crypto; history + WS, some delayed)
9. EODHD (stocks/forex/crypto; history + WS)
10. Blockchain.com (on-chain events only; WS, no history)

At least 6 (Binance, Kraken, Twelve Data, Finnhub, Polygon, EODHD) provide BOTH 
historical + real-time feeds, good for USD/BTC, USD/JPY, USD/AUX coverage.

-------------------------------------------------------------------------------
KOTLIN MODULES / SNIPPETS
-------------------------------------------------------------------------------

File: data/RemoteHistoryFetcher.kt
----------------------------------
package com.yourapp.data

import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET
import retrofit2.http.Query

// Data classes for Finnhub candles
data class CandleResponse(
    val c: List<Double>,  // close
    val h: List<Double>,  // high
    val l: List<Double>,  // low
    val o: List<Double>,  // open
    val s: String,        // status ("ok")
    val t: List<Long>,    // timestamps
    val v: List<Double>   // volume
)

interface FinnhubApi {
    @GET("stock/candle")
    suspend fun getCandles(
        @Query("symbol") symbol: String,
        @Query("resolution") resolution: String,
        @Query("from") from: Long,
        @Query("to") to: Long,
        @Query("token") token: String
    ): CandleResponse
}

class RemoteHistoryFetcher(
    baseUrl: String,
    private val apiKey: String
) {
    private val api: FinnhubApi

    init {
        val retrofit = Retrofit.Builder()
            .baseUrl(baseUrl)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        api = retrofit.create(FinnhubApi::class.java)
    }

    suspend fun fetchHistory(
        symbol: String,
        resolution: String,
        fromUnixSec: Long,
        toUnixSec: Long
    ): List<Candle> {
        val resp = api.getCandles(symbol, resolution, fromUnixSec, toUnixSec, apiKey)
        if (resp.s != "ok") error("Finnhub history fetch failed: status ${resp.s}")
        return resp.t.mapIndexed { idx, ts ->
            Candle(
                open = resp.o[idx],
                high = resp.h[idx],
                low = resp.l[idx],
                close = resp.c[idx],
                volume = resp.v.getOrNull(idx) ?: 0.0,
                timestamp = ts
            )
        }
    }
}

data class Candle(
    val open: Double,
    val high: Double,
    val low: Double,
    val close: Double,
    val volume: Double,
    val timestamp: Long
)

File: realtime/WebSocketClient.kt
---------------------------------
package com.yourapp.realtime

import okhttp3.*
import okio.ByteString
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow

sealed class RealTimeMessage {
    data class PriceUpdate(val symbol: String, val price: Double, val timestamp: Long) : RealTimeMessage()
    data class TradeUpdate(val symbol: String, val price: Double, val volume: Double, val timestamp: Long) : RealTimeMessage()
}

class RealTimeWebSocketClient(
    private val url: String,
    private val subscribeMessage: String,
    private val client: OkHttpClient = OkHttpClient()
) {
    private var webSocket: WebSocket? = null
    private val _messages = MutableSharedFlow<RealTimeMessage>(replay = 0)
    val messages: SharedFlow<RealTimeMessage> = _messages

    fun connect() {
        val request = Request.Builder().url(url).build()
        webSocket = client.newWebSocket(request, object : WebSocketListener() {
            override fun onOpen(ws: WebSocket, response: Response) {
                ws.send(subscribeMessage)
            }
            override fun onMessage(ws: WebSocket, text: String) {
                // parse JSON, emit PriceUpdate/TradeUpdate
            }
            override fun onMessage(ws: WebSocket, bytes: ByteString) {}
            override fun onClosing(ws: WebSocket, code: Int, reason: String) { ws.close(1000, null) }
            override fun onFailure(ws: WebSocket, t: Throwable, response: Response?) {}
        })
    }
    fun disconnect() { webSocket?.close(1000, "Client shutting down") }
}

Example usage
-------------
val historyFetcher = RemoteHistoryFetcher("https://finnhub.io/api/v1/", "YOUR_FINNHUB_KEY")
val historyUsdbtc = historyFetcher.fetchHistory(
    symbol = "BTCUSD", resolution = "1", fromUnixSec = start, toUnixSec = now
)

val finnhubWsUrl = "wss://ws.finnhub.io?token=YOUR_FINNHUB_KEY"
val subscribeMsg = """{"type":"subscribe","symbol":"USD/JPY"}"""
val rtClient = RealTimeWebSocketClient(finnhubWsUrl, subscribeMsg)
rtClient.connect()
// collect rtClient.messages flow for updates

-------------------------------------------------------------------------------
ARCHITECTURE NOTES
-------------------------------------------------------------------------------

1. Abstraction: define HistoryProvider / RealtimeProvider interfaces.
2. Symbol mapping: normalize symbols (BTCUSD vs BTC-USD vs USD/BTC).
3. Buffering/caching: cache history, use flows/queues for real-time.
4. Filtering: subscribe only to USD/BTC, USD/JPY, USD/AUX.
5. Fallbacks: if one provider fails, switch to another.
6. Backfill: fill real-time gaps with historical REST data.

-------------------------------------------------------------------------------
SUMMARY
-------------------------------------------------------------------------------

- You now have 10 providers: Binance, OKX, Kraken, Twelve Data, Finnhub, FMP, Polygon, Alpaca, EODHD, Blockchain.com.
- At least 6 give both history + real-time data.
- Kotlin modules included for: historical fetcher (Retrofit), real-time WS client (OkHttp).
- Example usage given for USD/BTC, USD/JPY; adapt to USD/AUX as needed.
- Build a normalization + fallback layer to integrate them into your app.
